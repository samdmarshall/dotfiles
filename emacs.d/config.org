#+AUTHOR: Samantha Demi
#+TITLE: Emacs Configuration
#+STARTUP: indent
#+STARTUP: showall

-----

* Package Management
** Sources
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+END_SRC

** Initial Setup
Give preference to using the package "use-package". This has some really nice syntax that wraps package initialization, requirements, and common configuration. It cuts down on a lot of boiler-plate and otherwise unnecessarily confusing code.

When the 'use-package' isn't installed, refresh the package index we have because new sources were added, then install 'use-package'. After that, enable the 'ensure' option so that packages that are defined as used get installed (as well as their dependencies) at run-time.
#+BEGIN_SRC emacs-lisp :tangle yes
(when (not (package-installed-p 'use-package))
  (package-refresh)
  (package-install 'use-package)
)
(require 'use-package)
(require 'use-package-ensure)
(setq use-package-always-ensure t)
#+END_SRC

** Updating Packages
To handle the process of making sure all used packages are up-to-date, use package "auto-package-update", then:
1) Before any updates happened, check that the user wants to do that when prompted
2) Decide if the old versions of packages should be automatically removed once it gets updated.
3) Check for package updates every __ days.
4) Decide when checking for updates should happen: On Startup
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-package-update
  :config
  (setq auto-package-update-prompt-before-update t)
  (setq auto-package-update-delete-old-versions t)
  (setq auto-package-update-interval 7)
  (auto-package-update-maybe)
)
#+END_SRC

* (Better) Emacs Defaults

** Splash-Screen
Disable the default splash-screen.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default inhibit-splash-screen t)
#+END_SRC

** Scratch Buffer
Close the ~*scratch*~ buffer, never used in my workflow. Set the default text to an empty string and force-close the buffer if it is open.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default initial-scratch-message "")
(when (member "*scratch*" (buffer-list))
  (kill-buffer "*scratch*"))
#+END_SRC

** Indentation
I prefer indentation as spaces with an indent width of 2 (primarily due to Nim's style-guide and syntax enforcement).
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default tab-width 2)
(setq-default standard-indent 2)
(setq-default indent-tabs-mode nil)
(setq-default tab-always-indent 'complete)
#+END_SRC

** Backup Files
Disable the automatic creation of backup-files. My experience with this has been unpleasant, with lots of littering on the file-system. I have good saving reflexes (save very very frequently) and have saves be written as separate files then copied over the original, so data-loss is unlikely.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq make-backup-files nil)
(setq create-lockfile nil)
(setq backup-by-copying t)
#+END_SRC

** Window Geometry
Start in fullscreen, personal preference for use on my tablet.
#+BEGIN_SRC emacs-lisp :tangle yes
(add-to-list 'default-frame-alist '(fullscreen . fullboth))
#+END_SRC

** Fonts
Use "Fira Code Retina", with a size of at-least 13pt (because my vision sucks T_T)
#+BEGIN_SRC emacs-lisp :tangle yes
(set-face-attribute 'default nil
  :family "Fira Code Retina"
  :height 130                     ; 1 unit == 1/10pt
)
(setq scalable-fonts-allowed t)
#+END_SRC

** Selection
This needs some tweaking, the ease of accidentally right-click and selecting a region of text only to also make a destructive action occur is too frequent for my liking. However this seems to be the only way to over-write a selected region with new content, normally emacs will just insert new content at the end of the selected region.
#+BEGIN_SRC emacs-lisp :tangle yes
(delete-selection-mode t)
(transient-mark-mode t)
#+END_SRC

** Clipboard
Enable integration with xclip, so copy-and-paste with windows and the rest of the system works!
#+BEGIN_SRC emacs-lisp :tangle yes
(setq x-select-enable-clipboard t)
(setq select-enable-clipboard t)
#+END_SRC

** Mouse
I love using a mouse, deal with it.
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'mouse)
(xterm-mouse-mode t)
(setq mouse-sel-mode t)

(setq mouse-1-click-follows-link t)
(setq mouse-1-click-in-non-selected-windows nil)
#+END_SRC

** ido
The built-in package ~ido~ (read as: "i, do") is wonderful and fantastic and should be enabled everywhere for everything!!
#+BEGIN_SRC emacs-lisp :tangle yes
(require 'ido)
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(ido-mode t)
#+END_SRC

** Word-wrap
Enable visual word-wrap globally. If lines are too long (run past the edge of the window/frame) then wrap onto the next line using whole-words, this prevents weird visual splits.
#+BEGIN_SRC emacs-lisp :tangle yes
(global-visual-line-mode t)
#+END_SRC

** Misc.

*** Display Current Time
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default display-time-default-load-average nil)
(display-time-mode t)
#+END_SRC

*** Turn the damn bell off
really though, the fuckin' bell ringing constantly is awful and it must die.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq ring-bell-function 'ignore)
#+END_SRC

* Org Mode
It's my intention to try to use Org-mode as a personal organizer. Thus far it has been incredibly helpful and allows me to keep track of a lot of information my brain isn't able to anymore. I have created many "project-/concept/.org" files to: gather, collect, organize, and respond to data related to a particular concept or specific subject-matter.
** Setup [fn:org-mode]
First comes initial setup of the main "org-mode" package. These settings allow me to customize and create processes to keep everything in order and on-track.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package org
  :config
  (setq initial-major-mode 'org-mode) ; Default to Org-Mode, as that will often be the case.

  ;; Add custom keywords
  (setq org-todo-keywords '(
    ;; Template: (sequence "ACTIONABLE_STATE(abbrev)" "|" "COMPLETION_STATE(abbrev)")

    ;; General Tasks TODO Keywords
    (sequence "TODO(t)" "STARTED(s)" "WAITING(w)" "FOLLOWUP(f)" "|" "DONE(d)" "CANCELED(c)")

    ;; Meeting/Event TODO Keywords
    (sequence                                    "TENTATIVE(m)" "|" "CONFIRMED(y)" "DECLINED(n)" "CANCELED(c)")

    ;; Appointment TODO Keywords
    (sequence                          "ASAP(a)" "REQUESTED(r)" "|" "BOOKED(b)" "CANCELED(c)")

    ))

  (setq org-todo-keyword-faces '(
    ;; Template: ("KEYWORD" . face-defintion)
    ;; Face Definition Template: (:foreground "color" :weight value :background "color" :box border-geometry)
    ;; Border Geometry Template: (:line-width integer)

    ;; General Tasks TODO Keyword Faces
    ("TODO"     . org-todo)
    ("STARTED"  . (:foreground "orange"  :weight bold :background "yellow" :box (:line-width 1)))
    ("WAITING"  . (:foreground "blue"    :weight bold :background "cyan"   :box (:line-width 1)))
    ("FOLLOWUP" . (:foreground "red"     :weight bold :background "orange" :box (:line-width 1)))
    ("DONE"     . org-done)
    ("CANCELED" . (:foreground "grey"    :weight bold :background "white"  :box (:line-width 1)))

    ;; Meeting/Event TODO Keyword Faces
    ("TENTATIVE" . (:foreground "orange" :weight bold :background "yellow" :box (:line-width 1)))
    ("CONFIRMED" . org-done)
    ("DECLINED"  . (:foreground "black"  :weight bold :background "grey"   :box (:line-width 1)))
    ("CANCELED"  . (:foreground "grey"   :weight bold :background "white"  :box (:line-width 1)))

    ;; Appointment TODO Keyword Faces
    ("ASAP"      . org-todo)
    ("REQUESTED" . (:foreground "orange" :weight bold :background "yellow" :box (:line-width 1)))
    ("BOOKED"    . org-done)
    ("CANCELED"  . (:foreground "grey"   :weight bold :background "white"  :box (:line-width 1)))

    ))


  ;; Custom Tags for Org-mode headings
  (setq org-tag-alist '(
    (:startgroup . nil)                ; Opening marker of a group of tags
    ("CURRENT" . nil) (:newline . nil) ; Tag item followed by indicator for this tag to insert a newline after it
    ("ONGOING" . nil) (:newline . nil) ; ^^^ ditto
    (:endgroup . nil)                  ; Closing marker of a group of tags
  ))

  ;; Custom Tag Faces
  (setq org-tag-faces '(
    ("CURRENT" . org-done) ; Using pre-defined faces, follows same template as the keyword faces above.
    ("ONGOING" . org-done)
  ))

  ;; Normally tags will be inherited by all sub-headings, disable that in these cases.
  (setq org-tags-exclude-from-inheritance '(
    "ONGOING"
    "CURRENT"
  ))

  ;; Insert date+time of marking a TODO item to a completed state.
  (setq org-log-done 'time)

  ;; If a TODO item is altered from a completed_state to an actionable_state, preserve the "CLOSED:" entry it has
  (setq org-closed-keep-when-no-todo t)

  ;; Set path to the default directory that Org-mode files should be found in.
  (setq org-directory (expand-file-name "~/org"))
  ;; Set the search pattern for generating Org-mode's Agenda.
  (setq org-agenda-files (directory-files org-directory t "^project\-.*\.org$"))

  ;; Disable for now, this needs more work.
  ;; The intent is to automatically export an html copy of the .org file, (as well as backing it up to iCloud+WebDAV) on save. this should be an async on-save hook only when Org-mode is active.
  ;(defun save-and-export-org-mode()
  ;  (when (eq major-mode 'org-mode) (org-html-export-to-html t t))
  ;  )
  ;(add-hook 'after-save-hook 'save-and-export-org-mode)
)
#+END_SRC

** Calendar Framework [fn:calfw]
This package creates a new buffer that has a ASCII diagram of a calendar with items generated from ~org-agenda~. It is necessary to generate the agenda before generating the calendar or it won't show anything. Each top-level project (pattern defined via ~org-agenda-files~) has a different color attached to it for it's scheduled items.
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package calfw
  :after (org)    ; load after org-mode package is finished.
  :config
  (setq calendar-week-start-day 1) ; weeks start on monday
)

;; Additional enhancement components to the framework.
(use-package calfw-cal
  :after (calfw))
(use-package calfw-ical
  :after (calfw-cal))
(use-package calfw-org
  :after (calfw))
#+END_SRC

* Data Formats
** Config Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package config-general-mode)
#+END_SRC

** Crontab
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package crontab-mode)
#+END_SRC

** Dockerfile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dockerfile-mode)
#+END_SRC

** ini Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ini-mode)
#+END_SRC

** JSON
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package json-mode)
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package markdown-mode)
#+END_SRC

** MTG Deck Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mtg-deck-mode
  :delight "MtG "
)
#+END_SRC

** robots.txt Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package robots-txt-mode)
#+END_SRC

** SSH Config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ssh-config-mode)
#+END_SRC

** Toml Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package toml-mode)
#+END_SRC

** YAML Files
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package yaml-mode)
#+END_SRC

* External Tools
** Build Tools
*** CMake
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cmake-mode)
#+END_SRC

*** Makefiles
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package makefile-executor
  :hook
  (makefile-mode makefile-executor-mode)
)
#+END_SRC

*** Ninja
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ninja-mode)
#+END_SRC

** Clang-Format
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package clang-format)
#+END_SRC

** Company

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package company
  :config
  (global-company-mode)
)

(use-package company-ansible
  :after (company ansible))
(use-package company-box
  :after (company))
(use-package company-c-headers
  :after (company))
(use-package company-dict
  :after (company))
(use-package company-emoji
  :after (company))
(use-package company-lua
  :after (company lua-mode))
(use-package company-nginx
  :after (company nginx-mode))
(use-package company-quickhelp
  :after (company))
(use-package company-shell
  :after (company))
(use-package company-statistics
  :after (company))
(use-package company-suggest
  :after (company))
(use-package company-web
  :after (company))
#+END_SRC

** Flycheck
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package flycheck
  :hook
  (after-init global-flycheck-mode))

(use-package flycheck-clang-analyzer
  :after (flycheck)
  :config
  (flycheck-clang-analyzer-setup))
(use-package flycheck-clang-tidy
  :after (flycheck))
(use-package flycheck-clangcheck
  :after (flycheck))
(use-package flycheck-dtrace
  :after (flycheck dtrace-script-mode))
(use-package flycheck-mypy
  :after (flycheck python-mode))
(use-package flycheck-nim
  :after (flycheck nim-mode))
(use-package flycheck-nimsuggest
  :after (flycheck nim-mode))
(use-package flycheck-objc-clang
  :after (flycheck))
(use-package flycheck-pkg-config
  :after (flycheck))
(use-package flycheck-yamllint
  :after (flycheck yaml-mode))
#+END_SRC

** fzf
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fzf)
#+END_SRC

** Graphviz
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package graphviz-dot-mode)
#+END_SRC

** ngnix
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nginx-mode)
#+END_SRC

** Pandoc
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pandoc-mode)
#+END_SRC

** Password Store
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package pass)
(use-package password-store
  :after (pass))
(use-package password-store-otp
  :after (password-store))
#+END_SRC

** Version Control
*** Git
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gitconfig-mode)
(use-package gitignore-mode)
#+END_SRC

*** Mercurial
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hgrc-mode)
(use-package hgignore-mode)
#+END_SRC

** w3m
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package w3m)
#+END_SRC

* Languages
** Ansible
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ansible)
#+END_SRC

** Assembly
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nasm-mode)
(use-package mips-mode)
#+END_SRC

** Bison
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package bison-mode)
#+END_SRC

** CUDA
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cuda-mode)
#+END_SRC

** Dtrace
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dtrace-script-mode)
#+END_SRC

** Fish
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package fish-mode)

(use-package fish-completion
  :after (fish-mode))
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package lua-mode)
(use-package luarocks)
#+END_SRC

** Nim
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package nim-mode
  :after (company flycheck)
  :config
  (setq nimsuggest-path (expand-file-name "~/.nimble/bin/nimsuggest"))
  :hook (
    (nim-mode . nimsuggest-mode)
    (nimsuggest-mode . company-mode)
    (nimsuggest-mode . flycheck-mode)
    )
  )
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package python-mode)

(use-package pycoverage
  :after (python-mode))
(use-package pyenv-mode-auto
  :after (python-mode))
(use-package pyenv-mode
  :after (pyenv-mode-auto))
(use-package python-docstring
  :after (python-mode))
(use-package tox
  :after (python-mode))
(use-package virtualenv
  :after (python-mode))
#+END_SRC

** Typescript
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package typescript-mode)
#+END_SRC

** Web
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package web-mode)
(use-package web-beautify)
#+END_SRC

** Writing
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package wc-mode)
(use-package guess-language)
#+END_SRC

* Interface
** Start-up
*** Dashboard
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dashboard
  :config
  (dashboard-setup-startup-hook)
  (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
  ;(add-to-list 'dashboard-items '(agenda) t)
)
#+END_SRC

** Mode Line
*** Powerline
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package powerline
  :config
  (powerline-center-theme)
)
#+END_SRC

** Theme
*** Moe
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package moe-theme
  :after (powerline)
  :config
  (moe-light)
  (moe-theme-set-color 'magenta)
  (powerline-moe-theme)
  (setq powerline-arrow-shape 'rounded)
)
#+END_SRC

** Window Management
*** ace-popup-menu
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-popup-menu
  :config
  (ace-popup-menu-mode t)
)
#+END_SRC

*** popup
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package popup)
#+END_SRC

** Navigator
*** treemacs
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package treemacs)
#+END_SRC

** Key Bindings
*** CUA Mode
#+BEGIN_SRC emacs-lisp :tangle yes
(cua-mode t)
(setq cua-auto-mark-last-change t)
#+END_SRC

*** Hydra
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hydra)
#+END_SRC

** Editor
*** Auto-Complete
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package auto-complete
  :config
  (auto-complete-mode)
  (ac-config-default)
  (ac-set-trigger-key "TAB")
  (setq ac-auto-start nil)
)
#+END_SRC

*** Autopair
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package autopair)
#+END_SRC

*** Indent Guide
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package indent-guide)
#+END_SRC

*** Line Numbering
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hlinum
  :config
  (defface linum-highlight-face '((t (:weight bold :inherit default :foreground "black"))) :group 'linum)

  ;; enabling line numbers for files
  (defun linum-format-func (line)
    (let ((w (length (number-to-string (count-lines (point-min) (point-max))))))
      (propertize (format (format "%%%dd " w) line) 'face 'linum)))
  (setq linum-format 'linum-format-func)
)
#+END_SRC

*** Multiple Cursors
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package multiple-cursors)
#+END_SRC

*** Moving Text
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package move-text)
#+END_SRC
